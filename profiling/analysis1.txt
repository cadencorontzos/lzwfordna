--------------------------------------------------------------------------------
Profile data file 'callgrind.out.830' (creator: callgrind-3.20.0)
--------------------------------------------------------------------------------
I1 cache: 
D1 cache: 
LL cache: 
Timerange: Basic block 0 - 417554563
Trigger: Program termination
Profiled target:  ./lzwencode HaHi (PID 830, part 1)
Events recorded:  Ir
Events shown:     Ir
Event sort order: Ir
Thresholds:       99
Include dirs:     
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
Ir                     
--------------------------------------------------------------------------------
1,841,830,645 (100.0%)  PROGRAM TOTALS

--------------------------------------------------------------------------------
Ir                    file:function
--------------------------------------------------------------------------------
235,674,963 (12.80%)  ???:std::_Hash_bytes(void const*, unsigned long, unsigned long) [/usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.28]
227,697,949 (12.36%)  /usr/include/c++/9/bits/basic_string.h:LZW::encode(std::istream&, std::ostream&)
204,280,218 (11.09%)  bitio.cc:BitOutput::output_n_bits(int, int) [/home/ccorontzos/thesis/lzwcpp/lzwencode]
139,342,203 ( 7.57%)  ???:0x000000000018b6e0 [/usr/lib/x86_64-linux-gnu/libc-2.31.so]
128,371,160 ( 6.97%)  ???:std::istream::get() [/usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.28]
117,395,581 ( 6.37%)  /usr/include/c++/9/bits/char_traits.h:LZW::encode(std::istream&, std::ostream&)
108,920,168 ( 5.91%)  ???:std::istream::sentry::sentry(std::istream&, bool) [/usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.28]
 91,322,064 ( 4.96%)  /usr/include/c++/9/bits/basic_string.tcc:LZW::encode(std::istream&, std::ostream&)
 80,355,649 ( 4.36%)  ???:0x0000000000184cc0 [/usr/lib/x86_64-linux-gnu/libc-2.31.so]
 57,402,562 ( 3.12%)  ???:0x0000000000097a70 [/usr/lib/x86_64-linux-gnu/libc-2.31.so]
 50,962,260 ( 2.77%)  ???:std::ostream::put(char) [/usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.28]
 41,489,224 ( 2.25%)  ???:free [/usr/lib/x86_64-linux-gnu/ld-2.31.so]
 35,999,375 ( 1.95%)  lzw.cc:LZW::encode(std::istream&, std::ostream&) [/home/ccorontzos/thesis/lzwcpp/lzwencode]
 33,825,591 ( 1.84%)  /usr/include/c++/9/bits/hashtable.h:LZW::encode(std::istream&, std::ostream&)
 28,762,218 ( 1.56%)  /usr/include/c++/9/bits/hashtable_policy.h:LZW::encode(std::istream&, std::ostream&)
 27,441,120 ( 1.49%)  ???:std::ostream::sentry::sentry(std::ostream&) [/usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.28]
 19,525,579 ( 1.06%)  ???:malloc [/usr/lib/x86_64-linux-gnu/ld-2.31.so]
 19,450,025 ( 1.06%)  /usr/include/c++/9/bits/functional_hash.h:LZW::encode(std::istream&, std::ostream&)
 18,462,340 ( 1.00%)  ???:0x000000000010a440 [???]
 18,285,927 ( 0.99%)  /usr/include/c++/9/bits/hashtable.h:std::_Hashtable<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, int>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, int> >, std::__detail::_Select1st, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true> >::_M_insert_unique_node(unsigned long, unsigned long, std::__detail::_Hash_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, int>, true>*, unsigned long) [/home/ccorontzos/thesis/lzwcpp/lzwencode]
 16,936,689 ( 0.92%)  ???:0x000000000018bb60 [/usr/lib/x86_64-linux-gnu/libc-2.31.so]
 13,249,020 ( 0.72%)  /usr/include/c++/9/bits/hashtable_policy.h:std::__detail::_Map_base<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, int>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, int> >, std::__detail::_Select1st, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true>, true>::operator[](std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&&) [/home/ccorontzos/thesis/lzwcpp/lzwencode]
 11,381,300 ( 0.62%)  /usr/include/c++/9/bits/basic_string.tcc:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_replace(unsigned long, unsigned long, char const*, unsigned long) [/home/ccorontzos/thesis/lzwcpp/lzwencode]
 10,920,502 ( 0.59%)  /usr/include/c++/9/bits/hashtable_policy.h:std::__detail::_Map_base<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, int>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, int> >, std::__detail::_Select1st, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true>, true>::operator[](std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) [/home/ccorontzos/thesis/lzwcpp/lzwencode]
 10,488,079 ( 0.57%)  /usr/include/c++/9/bits/hashtable.h:std::_Hashtable<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, int>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, int> >, std::__detail::_Select1st, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true> >::_M_rehash(unsigned long, unsigned long const&) [/home/ccorontzos/thesis/lzwcpp/lzwencode]
  9,406,424 ( 0.51%)  ???:0x000000000010a320 [???]
  8,129,500 ( 0.44%)  /usr/include/c++/9/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_replace(unsigned long, unsigned long, char const*, unsigned long)
  7,780,017 ( 0.42%)  ???:0x00000000048de6a0 [???]
  7,780,012 ( 0.42%)  ???:0x000000000010a3b0 [???]
  7,780,012 ( 0.42%)  ???:0x000000000010a4c0 [???]
  4,474,349 ( 0.24%)  ???:operator new(unsigned long) [/usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.28]
  4,064,753 ( 0.22%)  /usr/include/c++/9/bits/basic_string.h:std::__detail::_Map_base<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, int>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, int> >, std::__detail::_Select1st, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true>, true>::operator[](std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&&)
  3,791,561 ( 0.21%)  /usr/include/c++/9/bits/hashtable.h:std::__detail::_Map_base<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, int>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, int> >, std::__detail::_Select1st, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true>, true>::operator[](std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&&)
  3,341,247 ( 0.18%)  /usr/include/c++/9/bits/hashtable.h:std::__detail::_Map_base<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, int>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, int> >, std::__detail::_Select1st, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true>, true>::operator[](std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&)
  3,254,587 ( 0.18%)  ???:std::__detail::_Prime_rehash_policy::_M_need_rehash(unsigned long, unsigned long, unsigned long) const [/usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.28]
  3,252,571 ( 0.18%)  /usr/include/c++/9/bits/unordered_map.h:LZW::encode(std::istream&, std::ostream&)
  2,613,445 ( 0.14%)  ???:0x00000000048def30 [???]
  2,613,416 ( 0.14%)  ???:0x000000000010a300 [???]
  2,075,677 ( 0.11%)  /usr/include/c++/9/bits/hashtable_policy.h:std::_Hashtable<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, int>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, int> >, std::__detail::_Select1st, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true> >::_M_rehash(unsigned long, unsigned long const&)
  2,034,428 ( 0.11%)  /usr/include/c++/9/bits/basic_string.h:std::__detail::_Map_base<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, int>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, int> >, std::__detail::_Select1st, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true>, true>::operator[](std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&)
  2,033,660 ( 0.11%)  /usr/include/c++/9/bits/functional_hash.h:std::__detail::_Map_base<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, int>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, int> >, std::__detail::_Select1st, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true>, true>::operator[](std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&)
  2,032,892 ( 0.11%)  /usr/include/c++/9/bits/char_traits.h:std::__detail::_Map_base<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, int>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, int> >, std::__detail::_Select1st, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true>, true>::operator[](std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&)

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/9/bits/char_traits.h
--------------------------------------------------------------------------------
Ir                  

-- line 292 ----------------------------------------
         .                 typedef char              char_type;
         .                 typedef int               int_type;
         .                 typedef streampos         pos_type;
         .                 typedef streamoff         off_type;
         .                 typedef mbstate_t         state_type;
         .           
         .                 static _GLIBCXX17_CONSTEXPR void
         .                 assign(char_type& __c1, const char_type& __c2) _GLIBCXX_NOEXCEPT
46,042,642 ( 2.50%)        { __c1 = __c2; }
         .           
         .                 static _GLIBCXX_CONSTEXPR bool
         .                 eq(const char_type& __c1, const char_type& __c2) _GLIBCXX_NOEXCEPT
         .                 { return __c1 == __c2; }
         .           
         .                 static _GLIBCXX_CONSTEXPR bool
         .                 lt(const char_type& __c1, const char_type& __c2) _GLIBCXX_NOEXCEPT
         .                 {
-- line 308 ----------------------------------------
-- line 309 ----------------------------------------
         .           	// LWG 467.
         .           	return (static_cast<unsigned char>(__c1)
         .           		< static_cast<unsigned char>(__c2));
         .                 }
         .           
         .                 static _GLIBCXX17_CONSTEXPR int
         .                 compare(const char_type* __s1, const char_type* __s2, size_t __n)
         .                 {
   812,952 ( 0.04%)  	if (__n == 0)
         .           	  return 0;
         .           #if __cplusplus >= 201703L
         .           	if (__builtin_constant_p(__n)
         .           	    && __constant_char_array_p(__s1, __n)
         .           	    && __constant_char_array_p(__s2, __n))
         .           	  {
         .           	    for (size_t __i = 0; __i < __n; ++__i)
         .           	      if (lt(__s1[__i], __s2[__i]))
         .           		return -1;
         .           	      else if (lt(__s2[__i], __s1[__i]))
         .           		return 1;
         .           	    return 0;
         .           	  }
         .           #endif
15,153,548 ( 0.82%)  	return __builtin_memcmp(__s1, __s2, __n);
76,807,564 ( 4.17%)  => ???:0x000000000010a3b0 (3,483,530x)
         .                 }
         .           
         .                 static _GLIBCXX17_CONSTEXPR size_t
         .                 length(const char_type* __s)
         .                 {
         .           #if __cplusplus >= 201703L
         .           	if (__constant_string_p(__s))
         .           	  return __gnu_cxx::char_traits<char_type>::length(__s);
         .           #endif
        27 ( 0.00%)  	return __builtin_strlen(__s);
        36 ( 0.00%)  => ???:0x000000000010a3a0 (2x)
         .                 }
         .           
         .                 static _GLIBCXX17_CONSTEXPR const char_type*
         .                 find(const char_type* __s, size_t __n, const char_type& __a)
         .                 {
         .           	if (__n == 0)
         .           	  return 0;
         .           #if __cplusplus >= 201703L
-- line 350 ----------------------------------------
-- line 362 ----------------------------------------
         .           	if (__n == 0)
         .           	  return __s1;
         .           	return static_cast<char_type*>(__builtin_memmove(__s1, __s2, __n));
         .                 }
         .           
         .                 static char_type*
         .                 copy(char_type* __s1, const char_type* __s2, size_t __n)
         .                 {
15,560,028 ( 0.84%)  	if (__n == 0)
         .           	  return __s1;
44,298,223 ( 2.41%)  	return static_cast<char_type*>(__builtin_memcpy(__s1, __s2, __n));
        13 ( 0.00%)  => ???:0x000000000010a440 (1x)
         .                 }
         .           
         .                 static char_type*
         .                 assign(char_type* __s, size_t __n, char_type __a)
         .                 {
         .           	if (__n == 0)
         .           	  return __s;
         .           	return static_cast<char_type*>(__builtin_memset(__s, __a, __n));
-- line 380 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/9/bits/hashtable_policy.h
--------------------------------------------------------------------------------
Ir                  

-- line 210 ----------------------------------------
         .              *  template parameter of class template _Hashtable controls whether
         .              *  nodes also store a hash code. In some cases (e.g. strings) this
         .              *  may be a performance win.
         .              */
         .             struct _Hash_node_base
         .             {
         .               _Hash_node_base* _M_nxt;
         .           
   406,732 ( 0.02%)      _Hash_node_base() noexcept : _M_nxt() { }
         .           
         .               _Hash_node_base(_Hash_node_base* __next) noexcept : _M_nxt(__next) { }
         .             };
         .           
         .             /**
         .              *  struct _Hash_node_value_base
         .              *
         .              *  Node type with the value to store.
-- line 226 ----------------------------------------
-- line 425 ----------------------------------------
         .             {
         .               typedef std::size_t first_argument_type;
         .               typedef std::size_t second_argument_type;
         .               typedef std::size_t result_type;
         .           
         .               result_type
         .               operator()(first_argument_type __num,
         .           	       second_argument_type __den) const noexcept
23,457,145 ( 1.27%)      { return __num % __den; }
         .             };
         .           
         .             /// Default ranged hash function H.  In principle it should be a
         .             /// function object composed from objects of type H1 and H2 such that
         .             /// h(k, N) = h2(h1(k), N), but that would mean making extra copies of
         .             /// h1 and h2.  So instead we'll just use a tag to tell class template
         .             /// hashtable to do that composition.
         .             struct _Default_ranged_hash { };
-- line 441 ----------------------------------------
-- line 442 ----------------------------------------
         .           
         .             /// Default value for rehash policy.  Bucket size is (usually) the
         .             /// smallest prime that keeps the load factor small enough.
         .             struct _Prime_rehash_policy
         .             {
         .               using __has_load_factor = std::true_type;
         .           
         .               _Prime_rehash_policy(float __z = 1.0) noexcept
         2 ( 0.00%)      : _M_max_load_factor(__z), _M_next_resize(0) { }
         .           
         .               float
         .               max_load_factor() const noexcept
         .               { return _M_max_load_factor; }
         .           
         .               // Return a bucket size no smaller than n.
         .               std::size_t
         .               _M_next_bkt(std::size_t __n) const;
-- line 458 ----------------------------------------
-- line 681 ----------------------------------------
         .                 const mapped_type&
         .                 at(const key_type& __k) const;
         .               };
         .           
         .             template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,
         .           	   typename _H1, typename _H2, typename _Hash,
         .           	   typename _RehashPolicy, typename _Traits>
         .               auto
 4,067,320 ( 0.22%)      _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
         .           	      _H1, _H2, _Hash, _RehashPolicy, _Traits, true>::
         .               operator[](const key_type& __k)
         .               -> mapped_type&
         .               {
         .                 __hashtable* __h = static_cast<__hashtable*>(this);
         .                 __hash_code __code = __h->_M_hash_code(__k);
   406,732 ( 0.02%)        std::size_t __n = __h->_M_bucket_index(__k, __code);
         .                 __node_type* __p = __h->_M_find_node(__n, __k, __code);
         .           
         .                 if (!__p)
         .           	{
         .           	  __p = __h->_M_allocate_node(std::piecewise_construct,
         .           				      std::tuple<const key_type&>(__k),
         .           				      std::tuple<>());
     1,792 ( 0.00%)  	  return __h->_M_insert_unique_node(__n, __code, __p)->second;
    24,435 ( 0.00%)  => /usr/include/c++/9/bits/hashtable.h:std::_Hashtable<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, int>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, int> >, std::__detail::_Select1st, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true> >::_M_insert_unique_node(unsigned long, unsigned long, std::__detail::_Hash_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, int>, true>*, unsigned long) (256x)
         .           	}
         .           
   406,476 ( 0.02%)        return __p->_M_v().second;
 3,253,856 ( 0.18%)      }
         .           
         .             template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,
         .           	   typename _H1, typename _H2, typename _Hash,
         .           	   typename _RehashPolicy, typename _Traits>
         .               auto
 4,064,750 ( 0.22%)      _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
         .           	      _H1, _H2, _Hash, _RehashPolicy, _Traits, true>::
         .               operator[](key_type&& __k)
         .               -> mapped_type&
         .               {
         .                 __hashtable* __h = static_cast<__hashtable*>(this);
         .                 __hash_code __code = __h->_M_hash_code(__k);
   406,475 ( 0.02%)        std::size_t __n = __h->_M_bucket_index(__k, __code);
         .                 __node_type* __p = __h->_M_find_node(__n, __k, __code);
         .           
         .                 if (!__p)
         .           	{
         .           	  __p = __h->_M_allocate_node(std::piecewise_construct,
         .           				      std::forward_as_tuple(std::move(__k)),
         .           				      std::tuple<>());
 2,438,850 ( 0.13%)  	  return __h->_M_insert_unique_node(__n, __code, __p)->second;
47,145,520 ( 2.56%)  => /usr/include/c++/9/bits/hashtable.h:std::_Hashtable<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, int>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, int> >, std::__detail::_Select1st, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true> >::_M_insert_unique_node(unsigned long, unsigned long, std::__detail::_Hash_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, int>, true>*, unsigned long) (406,475x)
         .           	}
         .           
         .                 return __p->_M_v().second;
 3,251,800 ( 0.18%)      }
         .           
         .             template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,
         .           	   typename _H1, typename _H2, typename _Hash,
         .           	   typename _RehashPolicy, typename _Traits>
         .               auto
         .               _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
         .           	      _H1, _H2, _Hash, _RehashPolicy, _Traits, true>::
         .               at(const key_type& __k)
-- line 741 ----------------------------------------
-- line 1392 ----------------------------------------
         .                 std::size_t
         .                 _M_bucket_index(const __node_type* __p, std::size_t __n) const
         .           	noexcept( noexcept(declval<const _H2&>()((__hash_code)0,
         .           						 (std::size_t)0)) )
         .                 { return _M_h2()(__p->_M_hash_code, __n); }
         .           
         .                 void
         .                 _M_store_code(__node_type* __n, __hash_code __c) const
   406,731 ( 0.02%)        { __n->_M_hash_code = __c; }
         .           
         .                 void
         .                 _M_copy_code(__node_type* __to, const __node_type* __from) const
         .                 { __to->_M_hash_code = __from->_M_hash_code; }
         .           
         .                 void
         .                 _M_swap(_Hash_code_base& __x)
         .                 {
-- line 1408 ----------------------------------------
-- line 1442 ----------------------------------------
         .             /// Specialization.
         .             template<typename _Key, typename _Value, typename _ExtractKey,
         .           	   typename _Equal, typename _HashCodeType>
         .             struct _Equal_helper<_Key, _Value, _ExtractKey, _Equal, _HashCodeType, true>
         .             {
         .               static bool
         .               _S_equals(const _Equal& __eq, const _ExtractKey& __extract,
         .           	      const _Key& __k, _HashCodeType __c, _Hash_node<_Value, true>* __n)
12,226,870 ( 0.66%)      { return __c == __n->_M_hash_code && __eq(__k, __extract(__n->_M_v())); }
         .             };
         .           
         .             /// Specialization.
         .             template<typename _Key, typename _Value, typename _ExtractKey,
         .           	   typename _Equal, typename _HashCodeType>
         .             struct _Equal_helper<_Key, _Value, _ExtractKey, _Equal, _HashCodeType, false>
         .             {
         .               static bool
-- line 1458 ----------------------------------------
-- line 2112 ----------------------------------------
         .                 __n->~__node_type();
         .                 __node_alloc_traits::deallocate(_M_node_allocator(), __ptr, 1);
         .               }
         .           
         .             template<typename _NodeAlloc>
         .               void
         .               _Hashtable_alloc<_NodeAlloc>::_M_deallocate_nodes(__node_type* __n)
         .               {
   813,464 ( 0.04%)        while (__n)
         .           	{
         .           	  __node_type* __tmp = __n;
   406,731 ( 0.02%)  	  __n = __n->_M_next();
         .           	  _M_deallocate_node(__tmp);
         .           	}
         .               }
         .           
         .             template<typename _NodeAlloc>
         .               typename _Hashtable_alloc<_NodeAlloc>::__bucket_type*
         .               _Hashtable_alloc<_NodeAlloc>::_M_allocate_buckets(std::size_t __n)
         .               {
         .                 __bucket_alloc_type __alloc(_M_node_allocator());
         .           
         .                 auto __ptr = __bucket_alloc_traits::allocate(__alloc, __n);
         .                 __bucket_type* __p = std::__to_address(__ptr);
        64 ( 0.00%)        __builtin_memset(__p, 0, __n * sizeof(__bucket_type));
11,235,128 ( 0.61%)  => ???:0x000000000010a3f0 (16x)
         .                 return __p;
         .               }
         .           
         .             template<typename _NodeAlloc>
         .               void
         .               _Hashtable_alloc<_NodeAlloc>::_M_deallocate_buckets(__bucket_type* __bkts,
         .           							std::size_t __n)
         .               {
-- line 2144 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/9/bits/basic_string.h
--------------------------------------------------------------------------------
Ir                  

-- line 153 ----------------------------------------
         .                 // Use empty-base optimization: http://www.cantrip.org/emptyopt.html
         .                 struct _Alloc_hider : allocator_type // TODO check __is_final
         .                 {
         .           #if __cplusplus < 201103L
         .           	_Alloc_hider(pointer __dat, const _Alloc& __a = _Alloc())
         .           	: allocator_type(__a), _M_p(__dat) { }
         .           #else
         .           	_Alloc_hider(pointer __dat, const _Alloc& __a)
       264 ( 0.00%)  	: allocator_type(__a), _M_p(__dat) { }
         .           
         .           	_Alloc_hider(pointer __dat, _Alloc&& __a = _Alloc())
15,560,279 ( 0.84%)  	: allocator_type(std::move(__a)), _M_p(__dat) { }
         .           #endif
         .           
         .           	pointer _M_p; // The actual data.
         .                 };
         .           
         .                 _Alloc_hider	_M_dataplus;
         .                 size_type		_M_string_length;
         .           
-- line 172 ----------------------------------------
-- line 175 ----------------------------------------
         .                 union
         .                 {
         .           	_CharT           _M_local_buf[_S_local_capacity + 1];
         .           	size_type        _M_allocated_capacity;
         .                 };
         .           
         .                 void
         .                 _M_data(pointer __p)
   406,488 ( 0.02%)        { _M_dataplus._M_p = __p; }
         .           
         .                 void
         .                 _M_length(size_type __length)
24,559,983 ( 1.33%)        { _M_string_length = __length; }
         .           
         .                 pointer
         .                 _M_data() const
         .                 { return _M_dataplus._M_p; }
         .           
         .                 pointer
         .                 _M_local_data()
         .                 {
         .           #if __cplusplus >= 201103L
   813,213 ( 0.04%)  	return std::pointer_traits<pointer>::pointer_to(*_M_local_buf);
         .           #else
         .           	return pointer(_M_local_buf);
         .           #endif
         .                 }
         .           
         .                 const_pointer
         .                 _M_local_data() const
         .                 {
         .           #if __cplusplus >= 201103L
 1,626,164 ( 0.09%)  	return std::pointer_traits<const_pointer>::pointer_to(*_M_local_buf);
         .           #else
         .           	return const_pointer(_M_local_buf);
         .           #endif
         .                 }
         .           
         .                 void
         .                 _M_capacity(size_type __capacity)
        15 ( 0.00%)        { _M_allocated_capacity = __capacity; }
         .           
         .                 void
         .                 _M_set_length(size_type __n)
         .                 {
         .           	_M_length(__n);
         .           	traits_type::assign(_M_data()[__n], _CharT());
 3,483,530 ( 0.19%)        }
         .           
         .                 bool
         .                 _M_is_local() const
21,482,928 ( 1.17%)        { return _M_data() == _M_local_data(); }
         .           
         .                 // Create & Destroy
         .                 pointer
         .                 _M_create(size_type&, size_type);
         .           
         .                 void
         .                 _M_dispose()
         .                 {
16,374,023 ( 0.89%)  	if (!_M_is_local())
         .           	  _M_destroy(_M_allocated_capacity);
         .                 }
         .           
         .                 void
         .                 _M_destroy(size_type __size) throw()
         .                 { _Alloc_traits::deallocate(_M_get_allocator(), _M_data(), __size + 1); }
         .           
         .                 // _M_construct_aux is used to implement the 21.3.1 para 15 which
-- line 243 ----------------------------------------
-- line 318 ----------------------------------------
         .           				       "this->size() (which is %zu)"),
         .           				   __s, __pos, this->size());
         .           	return __pos;
         .                 }
         .           
         .                 void
         .                 _M_check_length(size_type __n1, size_type __n2, const char* __s) const
         .                 {
25,778,892 ( 1.40%)  	if (this->max_size() - (this->size() - __n1) < __n2)
         .           	  __throw_length_error(__N(__s));
         .                 }
         .           
         .           
         .                 // NB: _M_limit doesn't check for a bad __pos value.
         .                 size_type
         .                 _M_limit(size_type __pos, size_type __off) const _GLIBCXX_NOEXCEPT
         .                 {
-- line 334 ----------------------------------------
-- line 336 ----------------------------------------
         .           	return __testoff ? __off : this->size() - __pos;
         .                 }
         .           
         .                 // True if _Rep and source do not overlap.
         .                 bool
         .                 _M_disjunct(const _CharT* __s) const _GLIBCXX_NOEXCEPT
         .                 {
         .           	return (less<const _CharT*>()(__s, _M_data())
   812,950 ( 0.04%)  		|| less<const _CharT*>()(_M_data() + this->size(), __s));
         .                 }
         .           
         .                 // When __n = 1 way faster than the general multichar
         .                 // traits_type::copy/move/assign.
         .                 static void
         .                 _S_copy(_CharT* __d, const _CharT* __s, size_type __n)
         .                 {
22,527,610 ( 1.22%)  	if (__n == 1)
 1,219,684 ( 0.07%)  	  traits_type::assign(*__d, *__s);
         .           	else
         .           	  traits_type::copy(__d, __s, __n);
         .                 }
         .           
         .                 static void
         .                 _S_move(_CharT* __d, const _CharT* __s, size_type __n)
         .                 {
         .           	if (__n == 1)
-- line 361 ----------------------------------------
-- line 447 ----------------------------------------
         .           
         .                 /**
         .                  *  @brief  Construct string with copy of value of @a __str.
         .                  *  @param  __str  Source string.
         .                  */
         .                 basic_string(const basic_string& __str)
         .                 : _M_dataplus(_M_local_data(),
         .           		    _Alloc_traits::_S_select_on_copy(__str._M_get_allocator()))
15,560,534 ( 0.84%)        { _M_construct(__str._M_data(), __str._M_data() + __str.length()); }
         .           
         .                 // _GLIBCXX_RESOLVE_LIB_DEFECTS
         .                 // 2583. no way to supply an allocator for basic_string(str, pos)
         .                 /**
         .                  *  @brief  Construct string as copy of a substring.
         .                  *  @param  __str  Source string.
         .                  *  @param  __pos  Index of first character to copy from.
         .                  *  @param  __a  Allocator to use.
-- line 463 ----------------------------------------
-- line 521 ----------------------------------------
         .                  *  @param  __s  Source C string.
         .                  *  @param  __a  Allocator to use (default is default allocator).
         .                  */
         .           #if __cpp_deduction_guides && ! defined _GLIBCXX_DEFINING_STRING_INSTANTIATIONS
         .                 // _GLIBCXX_RESOLVE_LIB_DEFECTS
         .                 // 3076. basic_string CTAD ambiguity
         .                 template<typename = _RequireAllocator<_Alloc>>
         .           #endif
        12 ( 0.00%)        basic_string(const _CharT* __s, const _Alloc& __a = _Alloc())
         .                 : _M_dataplus(_M_local_data(), __a)
        18 ( 0.00%)        { _M_construct(__s, __s ? __s + traits_type::length(__s) : __s+npos); }
         .           
         .                 /**
         .                  *  @brief  Construct string as multiple characters.
         .                  *  @param  __n  Number of characters.
         .                  *  @param  __c  Character to use.
         .                  *  @param  __a  Allocator to use (default is default allocator).
         .                  */
         .           #if __cpp_deduction_guides && ! defined _GLIBCXX_DEFINING_STRING_INSTANTIATIONS
-- line 539 ----------------------------------------
-- line 551 ----------------------------------------
         .                  *  @param  __str  Source string.
         .                  *
         .                  *  The newly-created string contains the exact contents of @a __str.
         .                  *  @a __str is a valid, but unspecified string.
         .                  **/
         .                 basic_string(basic_string&& __str) noexcept
         .                 : _M_dataplus(_M_local_data(), std::move(__str._M_get_allocator()))
         .                 {
   812,956 ( 0.04%)  	if (__str._M_is_local())
         .           	  {
         .           	    traits_type::copy(_M_local_buf, __str._M_local_buf,
         .           			      _S_local_capacity + 1);
         .           	  }
         .           	else
         .           	  {
         .           	    _M_data(__str._M_data());
         .           	    _M_capacity(__str._M_allocated_capacity);
-- line 567 ----------------------------------------
-- line 743 ----------------------------------------
         .           	    // Destroy existing storage before replacing allocator.
         .           	    _M_destroy(_M_allocated_capacity);
         .           	    _M_data(_M_local_data());
         .           	    _M_set_length(0);
         .           	  }
         .           	// Replace allocator if POCMA is true.
         .           	std::__alloc_on_move(_M_get_allocator(), __str._M_get_allocator());
         .           
 6,967,060 ( 0.38%)  	if (__str._M_is_local())
         .           	  {
         .           	    // We've always got room for a short string, just copy it.
10,450,590 ( 0.57%)  	    if (__str.size())
         .           	      this->_S_copy(_M_data(), __str._M_data(), __str.size());
         .           	    _M_set_length(__str.size());
         .           	  }
         .           	else if (_Alloc_traits::_S_propagate_on_move_assign()
         .           	    || _Alloc_traits::_S_always_equal()
         .           	    || _M_get_allocator() == __str._M_get_allocator())
         .           	  {
         .           	    // Just move the allocated pointer, our allocator can free it.
-- line 762 ----------------------------------------
-- line 991 ----------------------------------------
         .           
         .                 /**
         .                  *  Returns the total number of characters that the %string can hold
         .                  *  before needing to allocate more memory.
         .                  */
         .                 size_type
         .                 capacity() const _GLIBCXX_NOEXCEPT
         .                 {
25,372,674 ( 1.38%)  	return _M_is_local() ? size_type(_S_local_capacity)
         .           	                     : _M_allocated_capacity;
         .                 }
         .           
         .                 /**
         .                  *  @brief  Attempt to preallocate enough memory for specified number of
         .                  *          characters.
         .                  *  @param  __res_arg  Number of characters required.
         .                  *  @throw  std::length_error  If @a __res_arg exceeds @c max_size().
-- line 1007 ----------------------------------------
-- line 1277 ----------------------------------------
         .                  *  @param __n  The number of characters to append.
         .                  *  @param __c  The character to use.
         .                  *  @return  Reference to this string.
         .                  *
         .                  *  Appends __n copies of __c to this string.
         .                  */
         .                 basic_string&
         .                 append(size_type __n, _CharT __c)
 7,780,010 ( 0.42%)        { return _M_replace_aux(this->size(), size_type(0), __n, __c); }
         .           
         .           #if __cplusplus >= 201103L
         .                 /**
         .                  *  @brief  Append an initializer_list of characters.
         .                  *  @param __l  The initializer_list of characters to append.
         .                  *  @return  Reference to this string.
         .                  */
         .                 basic_string&
-- line 1293 ----------------------------------------
-- line 1435 ----------------------------------------
         .                  *  The data is copied, so there is no dependence on @a __s once the
         .                  *  function returns.
         .                  */
         .                 basic_string&
         .                 assign(const _CharT* __s)
         .                 {
         .           	__glibcxx_requires_string(__s);
         .           	return _M_replace(size_type(0), this->size(), __s,
 2,438,850 ( 0.13%)  			  traits_type::length(__s));
22,356,125 ( 1.21%)  => /usr/include/c++/9/bits/basic_string.tcc:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_replace(unsigned long, unsigned long, char const*, unsigned long) (406,475x)
         .                 }
         .           
         .                 /**
         .                  *  @brief  Set value to multiple characters.
         .                  *  @param __n  Length of the resulting string.
         .                  *  @param __c  The character to use.
         .                  *  @return  Reference to this string.
         .                  *
-- line 1451 ----------------------------------------
-- line 2309 ----------------------------------------
         .                  *
         .                  *  This is a pointer to internal data.  It is undefined to modify
         .                  *  the contents through the returned pointer. To get a pointer that
         .                  *  allows modifying the contents use @c &str[0] instead,
         .                  *  (or in C++17 the non-const @c str.data() overload).
         .                 */
         .                 const _CharT*
         .                 data() const _GLIBCXX_NOEXCEPT
14,758,448 ( 0.80%)        { return _M_data(); }
         .           
         .           #if __cplusplus >= 201703L
         .                 /**
         .                  *  @brief  Return non-const pointer to contents.
         .                  *
         .                  *  This is a pointer to the character sequence held by the string.
         .                  *  Modifying the characters in the sequence is allowed.
         .                 */
-- line 2325 ----------------------------------------
-- line 6116 ----------------------------------------
         .             template<typename _CharT, typename _Traits, typename _Alloc>
         .               inline basic_string<_CharT, _Traits, _Alloc>
         .               operator+(_CharT __lhs,
         .           	      basic_string<_CharT, _Traits, _Alloc>&& __rhs)
         .               { return std::move(__rhs.insert(0, 1, __lhs)); }
         .           
         .             template<typename _CharT, typename _Traits, typename _Alloc>
         .               inline basic_string<_CharT, _Traits, _Alloc>
        20 ( 0.00%)      operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
         .           	      const _CharT* __rhs)
        18 ( 0.00%)      { return std::move(__lhs.append(__rhs)); }
         .           
         .             template<typename _CharT, typename _Traits, typename _Alloc>
         .               inline basic_string<_CharT, _Traits, _Alloc>
         .               operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
         .           	      _CharT __rhs)
         .               { return std::move(__lhs.append(1, __rhs)); }
         .           #endif
         .           
-- line 6134 ----------------------------------------
-- line 6146 ----------------------------------------
         .               _GLIBCXX_NOEXCEPT
         .               { return __lhs.compare(__rhs) == 0; }
         .           
         .             template<typename _CharT>
         .               inline
         .               typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type
         .               operator==(const basic_string<_CharT>& __lhs,
         .           	       const basic_string<_CharT>& __rhs) _GLIBCXX_NOEXCEPT
 4,096,088 ( 0.22%)      { return (__lhs.size() == __rhs.size()
19,043,554 ( 1.03%)  	      && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(),
         .           						    __lhs.size())); }
         .           
         .             /**
         .              *  @brief  Test equivalence of C string and string.
         .              *  @param __lhs  C string.
         .              *  @param __rhs  String.
         .              *  @return  True if @a __rhs.compare(@a __lhs) == 0.  False otherwise.
         .              */
-- line 6163 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: lzw.cc
--------------------------------------------------------------------------------
Ir                  

-- line 6 ----------------------------------------
         .           #include <fstream>
         .           #include <chrono>
         .           #include <filesystem>
         .           #include <unordered_map>
         .           #include <climits>
         .           
         .           namespace fs = std::filesystem;
         .           
        14 ( 0.00%)  void LZW::encode(std::istream& input, std::ostream& output){
         .               
         .               // initialize starter dictionary
         .               // TODO: have a type for codeword, should be uint64t
         .               std::unordered_map<std::string, int> dictionary;
     1,033 ( 0.00%)      for (int i = 0; i < STARTING_DICT_SIZE; ++i){
       256 ( 0.00%)          std::string str1(1, char(i));
       256 ( 0.00%)          dictionary[str1] = i;
         .               }
         .            
         6 ( 0.00%)      BitOutput bit_output(output);
        78 ( 0.00%)  => /home/ccorontzos/thesis/lzwcpp/bitio.cc:BitOutput::~BitOutput() (1x)
         5 ( 0.00%)  => /home/ccorontzos/thesis/lzwcpp/bitio.cc:BitOutput::BitOutput(std::ostream&) (1x)
         .           
         .               // the current codeword we are using, and the size of the codewords
         .               // each time we use a codeword we will have to increment so all codewords are unique
         3 ( 0.00%)      int codeword = STARTING_CODEWORD;
         2 ( 0.00%)      int codeword_size = STARTING_CODE_SIZE;
         4 ( 0.00%)      int max_codeword_size = 1<<STARTING_CODE_SIZE;
         .           
         .               // the pieces of the file we are reading
         .               // current block is a string that we've seen before (its in the dictionary), next_character is the following character that we are looking at
         .               std::string currentBlock = "";
         .               char next_character;
         .           
         3 ( 0.00%)      next_character = input.get();
     4,059 ( 0.00%)  => ???:0x000000000010a4c0 (1x)
         .               // don't use -1 use constant
 7,780,015 ( 0.42%)      while(next_character != EOF){
         .           
         .                   // increment the codword size if the current codeword becomes too large
11,670,015 ( 0.63%)          if (codeword == max_codeword_size){
        10 ( 0.00%)              codeword_size += 1;
        10 ( 0.00%)              max_codeword_size<<= 1;
         .                   }
         .           
         .                   // if we've already seen the sequence, keep going
         .                   // TODO: use cend() and save this iterator
   406,475 ( 0.02%)          if (dictionary.find(currentBlock + next_character) != dictionary.end()){
         .                       currentBlock = currentBlock + next_character;
         .                   }
         .                   else{
         .           
         .                       // lookup the current block in the dictionary and output it, along with the new character
         .                       // shouldn't look up again
         .                       int code = dictionary[currentBlock];
 2,032,375 ( 0.11%)              bit_output.output_n_bits(code, codeword_size);
196,064,815 (10.65%)  => /home/ccorontzos/thesis/lzwcpp/bitio.cc:BitOutput::output_n_bits(int, int) (406,475x)
         .                       // TODO: static cast to unsigned (uint8t)
 1,219,425 ( 0.07%)              bit_output.output_n_bits((int) next_character, CHAR_BIT);
91,871,100 ( 4.99%)  => /home/ccorontzos/thesis/lzwcpp/bitio.cc:BitOutput::output_n_bits(int, int) (406,475x)
         .           
         .                       // add this new sequence to our dictionary
   812,950 ( 0.04%)              dictionary[currentBlock + next_character] = codeword;
   406,475 ( 0.02%)              codeword += 1;
         .                       currentBlock = "";
         .                   }
11,670,015 ( 0.63%)          next_character = input.get();
252,916,362 (13.73%)  => ???:0x000000000010a4c0 (3,890,005x)
         .               }
         .           
         .               // output special eof character
         5 ( 0.00%)      bit_output.output_n_bits(EOF_CODEWORD, codeword_size);
       491 ( 0.00%)  => /home/ccorontzos/thesis/lzwcpp/bitio.cc:BitOutput::output_n_bits(int, int) (1x)
         .           
         .               // after we've encoded, we either have 
         .               // no current block (case 0)
         .               // we have a current block that is a single character (case 1)
         .               // otherwise we have a current block > 1 byte (default)
         5 ( 0.00%)      switch (currentBlock.length()){
         .               case 0:
         .                   bit_output.output_bit(false);
         .                   bit_output.output_bit(false);
         .                   break;
         .               case 1:
         .                   bit_output.output_bit(false);
         .                   bit_output.output_bit(true);
         .                   bit_output.output_n_bits((int) currentBlock[0], CHAR_BIT);
         .                   break;
         .               default:
         4 ( 0.00%)          bit_output.output_bit(true);
        16 ( 0.00%)  => /home/ccorontzos/thesis/lzwcpp/bitio.cc:BitOutput::output_bit(bool) (1x)
         3 ( 0.00%)          bit_output.output_bit(true);
        84 ( 0.00%)  => /home/ccorontzos/thesis/lzwcpp/bitio.cc:BitOutput::output_bit(bool) (1x)
         .           
         .                   int code = dictionary[currentBlock];
         5 ( 0.00%)          bit_output.output_n_bits(code, codeword_size);
       488 ( 0.00%)  => /home/ccorontzos/thesis/lzwcpp/bitio.cc:BitOutput::output_n_bits(int, int) (1x)
         .                   break;
         .               }
        11 ( 0.00%)  }
         .           
         .           
         .           
         .           void LZW::decode(std::istream& input, std::ostream& output){
         .           
         .               // starting dictionary
         .               std::unordered_map<int, std::string> dictionary;
         .               for (int i = 0; i < STARTING_DICT_SIZE; ++i){
-- line 102 ----------------------------------------
-- line 145 ----------------------------------------
         .                   break;
         .               case 3:
         .                   int last_codeword = bit_input.read_n_bits(code_size);
         .                   auto decodedCodeword = dictionary.find(last_codeword);
         .                   output << decodedCodeword->second; 
         .                   break;
         .               }
         .           
         3 ( 0.00%)  }

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/9/bits/functional_hash.h
--------------------------------------------------------------------------------
Ir                  

-- line 189 ----------------------------------------
         .           
         .           #undef _Cxx_hashtable_define_trivial_hash
         .           
         .             struct _Hash_impl
         .             {
         .               static size_t
         .               hash(const void* __ptr, size_t __clength,
         .           	 size_t __seed = static_cast<size_t>(0xc70f6907UL))
23,516,060 ( 1.28%)      { return _Hash_bytes(__ptr, __clength, __seed); }
202,642,678 (11.00%)  => ???:0x000000000010a320 (3,890,005x)
         .           
         .               template<typename _Tp>
         .                 static size_t
         .                 hash(const _Tp& __val)
         .                 { return hash(&__val, sizeof(__val)); }
         .           
         .               template<typename _Tp>
         .                 static size_t
-- line 205 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/9/bits/unordered_map.h
--------------------------------------------------------------------------------
Ir                 

-- line 978 ----------------------------------------
        .                  *  data associated with the key specified in subscript.  If the key does
        .                  *  not exist, a pair with that key is created using default values, which
        .                  *  is then returned.
        .                  *
        .                  *  Lookup requires constant time.
        .                  */
        .                 mapped_type&
        .                 operator[](const key_type& __k)
2,033,146 ( 0.11%)        { return _M_h[__k]; }
52,526,832 ( 2.85%)  => /usr/include/c++/9/bits/hashtable_policy.h:std::__detail::_Map_base<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, int>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, int> >, std::__detail::_Select1st, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true>, true>::operator[](std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) (406,732x)
        .           
        .                 mapped_type&
        .                 operator[](key_type&& __k)
1,219,425 ( 0.07%)        { return _M_h[std::move(__k)]; }
178,202,389 ( 9.68%)  => /usr/include/c++/9/bits/hashtable_policy.h:std::__detail::_Map_base<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, int>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, int> >, std::__detail::_Select1st, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true>, true>::operator[](std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&&) (406,475x)
        .                 ///@}
        .           
        .                 ///@{
        .                 /**
        .                  *  @brief  Access to %unordered_map data.
        .                  *  @param  __k  The key for which data should be retrieved.
        .                  *  @return  A reference to the data whose key is equal to @a __k, if
        .                  *           such a data is present in the %unordered_map.
-- line 998 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/9/bits/hashtable.h
--------------------------------------------------------------------------------
Ir                  

-- line 347 ----------------------------------------
         .                 { return _M_uses_single_bucket(_M_buckets); }
         .           
         .                 __hashtable_alloc&
         .                 _M_base_alloc() { return *this; }
         .           
         .                 __bucket_type*
         .                 _M_allocate_buckets(size_type __n)
         .                 {
        32 ( 0.00%)  	if (__builtin_expect(__n == 1, false))
         .           	  {
         .           	    _M_single_bucket = nullptr;
         .           	    return &_M_single_bucket;
         .           	  }
         .           
         .           	return __hashtable_alloc::_M_allocate_buckets(__n);
         .                 }
         .           
         .                 void
         .                 _M_deallocate_buckets(__bucket_type* __bkts, size_type __n)
         .                 {
        34 ( 0.00%)  	if (_M_uses_single_bucket(__bkts))
         .           	  return;
         .           
         .           	__hashtable_alloc::_M_deallocate_buckets(__bkts, __n);
         .                 }
         .           
         .                 void
         .                 _M_deallocate_buckets()
        17 ( 0.00%)        { _M_deallocate_buckets(_M_buckets, _M_bucket_count); }
         .           
         .                 // Gets bucket begin, deals with the fact that non-empty buckets contain
         .                 // their before begin node.
         .                 __node_type*
         .                 _M_bucket_begin(size_type __bkt) const;
         .           
         .                 __node_type*
         .                 _M_begin() const
-- line 383 ----------------------------------------
-- line 430 ----------------------------------------
         .           	noexcept(_S_nothrow_move());
         .           
         .                 _Hashtable(_Hashtable&&, __node_alloc_type&&,
         .           		 false_type /* alloc always equal */);
         .           
         .           
         .               public:
         .                 // Constructor, destructor, assignment, swap
         6 ( 0.00%)        _Hashtable() = default;
         .                 _Hashtable(size_type __bucket_hint,
         .           		 const _H1&, const _H2&, const _Hash&,
         .           		 const _Equal&, const _ExtractKey&,
         .           		 const allocator_type&);
         .           
         .                 template<typename _InputIterator>
         .           	_Hashtable(_InputIterator __first, _InputIterator __last,
         .           		   size_type __bucket_hint,
-- line 446 ----------------------------------------
-- line 664 ----------------------------------------
         .           
         .                 std::pair<const_iterator, const_iterator>
         .                 equal_range(const key_type& __k) const;
         .           
         .               protected:
         .                 // Bucket index computation helpers.
         .                 size_type
         .                 _M_bucket_index(__node_type* __n) const noexcept
 2,223,418 ( 0.12%)        { return __hash_code_base::_M_bucket_index(__n, _M_bucket_count); }
         .           
         .                 size_type
         .                 _M_bucket_index(const key_type& __k, __hash_code __c) const
         .                 { return __hash_code_base::_M_bucket_index(__k, __c, _M_bucket_count); }
         .           
         .                 // Find and insert helper functions and types
         .                 // Find the node before the one matching the criteria.
         .                 __node_base*
-- line 680 ----------------------------------------
-- line 1445 ----------------------------------------
         .           	   typename _Traits>
         .               auto
         .               _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
         .           	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
         .               find(const key_type& __k)
         .               -> iterator
         .               {
         .                 __hash_code __code = this->_M_hash_code(__k);
 3,890,005 ( 0.21%)        std::size_t __n = _M_bucket_index(__k, __code);
         .                 __node_type* __p = _M_find_node(__n, __k, __code);
         .                 return __p ? iterator(__p) : end();
         .               }
         .           
         .             template<typename _Key, typename _Value,
         .           	   typename _Alloc, typename _ExtractKey, typename _Equal,
         .           	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
         .           	   typename _Traits>
-- line 1461 ----------------------------------------
-- line 1565 ----------------------------------------
         .           	   typename _Traits>
         .               auto
         .               _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
         .           	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
         .               _M_find_before_node(size_type __n, const key_type& __k,
         .           			__hash_code __code) const
         .               -> __node_base*
         .               {
 9,406,424 ( 0.51%)        __node_base* __prev_p = _M_buckets[__n];
 9,406,424 ( 0.51%)        if (!__prev_p)
         .           	return nullptr;
         .           
 4,914,988 ( 0.27%)        for (__node_type* __p = static_cast<__node_type*>(__prev_p->_M_nxt);;
         .           	   __p = __p->_M_next())
         .           	{
         .           	  if (this->_M_equals(__k, __code, __p))
         .           	    return __prev_p;
         .           
11,117,123 ( 0.60%)  	  if (!__p->_M_nxt || _M_bucket_index(__p->_M_next()) != __n)
         .           	    break;
         .           	  __prev_p = __p;
         .           	}
         .                 return nullptr;
         .               }
         .           
         .             template<typename _Key, typename _Value,
         .           	   typename _Alloc, typename _ExtractKey, typename _Equal,
         .           	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
         .           	   typename _Traits>
         .               void
         .               _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
         .           	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
         .               _M_insert_bucket_begin(size_type __bkt, __node_type* __node)
         .               {
 2,033,655 ( 0.11%)        if (_M_buckets[__bkt])
         .           	{
         .           	  // Bucket is not empty, we just need to insert the new node
         .           	  // after the bucket before begin.
   412,408 ( 0.02%)  	  __node->_M_nxt = _M_buckets[__bkt]->_M_nxt;
   412,408 ( 0.02%)  	  _M_buckets[__bkt]->_M_nxt = __node;
         .           	}
         .                 else
         .           	{
         .           	  // The bucket is empty, the new node is inserted at the
         .           	  // beginning of the singly-linked list and the bucket will
         .           	  // contain _M_before_begin pointer.
   401,054 ( 0.02%)  	  __node->_M_nxt = _M_before_begin._M_nxt;
   200,527 ( 0.01%)  	  _M_before_begin._M_nxt = __node;
   601,581 ( 0.03%)  	  if (__node->_M_nxt)
         .           	    // We must update former begin bucket that is pointing to
         .           	    // _M_before_begin.
   200,526 ( 0.01%)  	    _M_buckets[_M_bucket_index(__node->_M_next())] = __node;
   601,581 ( 0.03%)  	  _M_buckets[__bkt] = &_M_before_begin;
         .           	}
         .               }
         .           
         .             template<typename _Key, typename _Value,
         .           	   typename _Alloc, typename _ExtractKey, typename _Equal,
         .           	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
         .           	   typename _Traits>
         .               void
-- line 1625 ----------------------------------------
-- line 1725 ----------------------------------------
         .           	return _M_insert_multi_node(__hint._M_cur, __code, __node);
         .                 }
         .           
         .             template<typename _Key, typename _Value,
         .           	   typename _Alloc, typename _ExtractKey, typename _Equal,
         .           	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
         .           	   typename _Traits>
         .               auto
 5,694,234 ( 0.31%)      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
         .           	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
         .               _M_insert_unique_node(size_type __bkt, __hash_code __code,
         .           			  __node_type* __node, size_type __n_elt)
         .               -> iterator
         .               {
   813,462 ( 0.04%)        const __rehash_state& __saved_state = _M_rehash_policy._M_state();
 1,626,924 ( 0.09%)        std::pair<bool, std::size_t> __do_rehash
 4,070,797 ( 0.22%)  => ???:0x000000000010a4d0 (406,731x)
         .           	= _M_rehash_policy._M_need_rehash(_M_bucket_count, _M_element_count,
         .           					  __n_elt);
         .           
         .                 __try
         .           	{
   813,478 ( 0.04%)  	  if (__do_rehash.first)
         .           	    {
        48 ( 0.00%)  	      _M_rehash(__do_rehash.second, __saved_state);
23,804,858 ( 1.29%)  => /usr/include/c++/9/bits/hashtable.h:std::_Hashtable<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, int>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, int> >, std::__detail::_Select1st, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true> >::_M_rehash(unsigned long, unsigned long const&) (16x)
         .           	      __bkt = _M_bucket_index(this->_M_extract()(__node->_M_v()), __code);
         .           	    }
         .           
         .           	  this->_M_store_code(__node, __code);
         .           
         .           	  // Always insert at the beginning of the bucket.
         .           	  _M_insert_bucket_begin(__bkt, __node);
   406,731 ( 0.02%)  	  ++_M_element_count;
         .           	  return iterator(__node);
         .           	}
         .                 __catch(...)
         .           	{
         .           	  this->_M_deallocate_node(__node);
         .           	  __throw_exception_again;
         .           	}
 4,067,310 ( 0.22%)      }
         .           
         .             // Insert node, in bucket bkt if no rehash (assumes no element with its key
         .             // already present). Take ownership of the node, deallocate it on exception.
         .             template<typename _Key, typename _Value,
         .           	   typename _Alloc, typename _ExtractKey, typename _Equal,
         .           	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
         .           	   typename _Traits>
         .               auto
-- line 1772 ----------------------------------------
-- line 2055 ----------------------------------------
         .           	   typename _Alloc, typename _ExtractKey, typename _Equal,
         .           	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
         .           	   typename _Traits>
         .               void
         .               _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
         .           	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
         .               clear() noexcept
         .               {
         1 ( 0.00%)        this->_M_deallocate_nodes(_M_begin());
         5 ( 0.00%)        __builtin_memset(_M_buckets, 0, _M_bucket_count * sizeof(__bucket_type));
 5,701,595 ( 0.31%)  => ???:0x000000000010a3f0 (1x)
         1 ( 0.00%)        _M_element_count = 0;
         1 ( 0.00%)        _M_before_begin._M_nxt = nullptr;
         .               }
         .           
         .             template<typename _Key, typename _Value,
         .           	   typename _Alloc, typename _ExtractKey, typename _Equal,
         .           	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
         .           	   typename _Traits>
         .               void
         .               _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
-- line 2074 ----------------------------------------
-- line 2088 ----------------------------------------
         .           	_M_rehash_policy._M_reset(__saved_state);
         .               }
         .           
         .             template<typename _Key, typename _Value,
         .           	   typename _Alloc, typename _ExtractKey, typename _Equal,
         .           	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
         .           	   typename _Traits>
         .               void
       128 ( 0.00%)      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
         .           	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
         .               _M_rehash(size_type __n, const __rehash_state& __state)
         .               {
         .                 __try
         .           	{
         .           	  _M_rehash_aux(__n, __unique_keys());
         .           	}
         .                 __catch(...)
         .           	{
         .           	  // A failure here means that buckets allocation failed.  We only
         .           	  // have to restore hash policy previous state.
         .           	  _M_rehash_policy._M_reset(__state);
         .           	  __throw_exception_again;
         .           	}
        96 ( 0.00%)      }
         .           
         .             // Rehash when there is no equivalent elements.
         .             template<typename _Key, typename _Value,
         .           	   typename _Alloc, typename _ExtractKey, typename _Equal,
         .           	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
         .           	   typename _Traits>
         .               void
         .               _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
         .           	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
         .               _M_rehash_aux(size_type __n, std::true_type)
         .               {
         .                 __bucket_type* __new_buckets = _M_allocate_buckets(__n);
        16 ( 0.00%)        __node_type* __p = _M_begin();
        16 ( 0.00%)        _M_before_begin._M_nxt = nullptr;
        15 ( 0.00%)        std::size_t __bbegin_bkt = 0;
 2,075,655 ( 0.11%)        while (__p)
         .           	{
   691,871 ( 0.04%)  	  __node_type* __next = __p->_M_next();
         .           	  std::size_t __bkt = __hash_code_base::_M_bucket_index(__p, __n);
 2,767,484 ( 0.15%)  	  if (!__new_buckets[__bkt])
         .           	    {
 1,092,586 ( 0.06%)  	      __p->_M_nxt = _M_before_begin._M_nxt;
   546,293 ( 0.03%)  	      _M_before_begin._M_nxt = __p;
   546,323 ( 0.03%)  	      __new_buckets[__bkt] = &_M_before_begin;
 1,092,586 ( 0.06%)  	      if (__p->_M_nxt)
   546,278 ( 0.03%)  		__new_buckets[__bbegin_bkt] = __p;
   546,308 ( 0.03%)  	      __bbegin_bkt = __bkt;
         .           	    }
         .           	  else
         .           	    {
   291,156 ( 0.02%)  	      __p->_M_nxt = __new_buckets[__bkt]->_M_nxt;
   291,156 ( 0.02%)  	      __new_buckets[__bkt]->_M_nxt = __p;
         .           	    }
         .           	  __p = __next;
         .           	}
         .           
         .                 _M_deallocate_buckets();
        16 ( 0.00%)        _M_bucket_count = __n;
        16 ( 0.00%)        _M_buckets = __new_buckets;
         .               }
         .           
         .             // Rehash when there can be equivalent elements, preserve their relative
         .             // order.
         .             template<typename _Key, typename _Value,
         .           	   typename _Alloc, typename _ExtractKey, typename _Equal,
         .           	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
         .           	   typename _Traits>
-- line 2158 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/9/bits/basic_string.tcc
--------------------------------------------------------------------------------
Ir                  

-- line 129 ----------------------------------------
         .           
         .             template<typename _CharT, typename _Traits, typename _Alloc>
         .               typename basic_string<_CharT, _Traits, _Alloc>::pointer
         .               basic_string<_CharT, _Traits, _Alloc>::
         .               _M_create(size_type& __capacity, size_type __old_capacity)
         .               {
         .                 // _GLIBCXX_RESOLVE_LIB_DEFECTS
         .                 // 83.  String::npos vs. string::max_size()
        15 ( 0.00%)        if (__capacity > max_size())
         .           	std::__throw_length_error(__N("basic_string::_M_create"));
         .           
         .                 // The below implements an exponential growth policy, necessary to
         .                 // meet amortized linear time requirements of the library: see
         .                 // http://gcc.gnu.org/ml/libstdc++/2001-07/msg00085.html.
        24 ( 0.00%)        if (__capacity > __old_capacity && __capacity < 2 * __old_capacity)
         .           	{
         .           	  __capacity = 2 * __old_capacity;
         .           	  // Never allocate a string bigger than max_size.
         6 ( 0.00%)  	  if (__capacity > max_size())
         2 ( 0.00%)  	    __capacity = max_size();
         .           	}
         .           
         .                 // NB: Need an array of char_type[__capacity], plus a terminating
         .                 // null char_type() element.
        13 ( 0.00%)        return _Alloc_traits::allocate(_M_get_allocator(), __capacity + 1);
         .               }
         .           
         .             // NB: This is the special case for Input Iterators, used in
         .             // istreambuf_iterators, etc.
         .             // Input Iterators have a cost structure very different from
         .             // pointers, calling for a different coding style.
         .             template<typename _CharT, typename _Traits, typename _Alloc>
         .               template<typename _InIterator>
-- line 161 ----------------------------------------
-- line 203 ----------------------------------------
         .             template<typename _CharT, typename _Traits, typename _Alloc>
         .               template<typename _InIterator>
         .                 void
         .                 basic_string<_CharT, _Traits, _Alloc>::
         .                 _M_construct(_InIterator __beg, _InIterator __end,
         .           		   std::forward_iterator_tag)
         .                 {
         .           	// NB: Not required, but considered best practice.
38,901,335 ( 2.11%)  	if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
         .           	  std::__throw_logic_error(__N("basic_string::"
         .           				       "_M_construct null not valid"));
         .           
         .           	size_type __dnew = static_cast<size_type>(std::distance(__beg, __end));
         .           
15,560,540 ( 0.84%)  	if (__dnew > size_type(_S_local_capacity))
         .           	  {
         .           	    _M_data(_M_create(__dnew, size_type(0)));
         .           	    _M_capacity(__dnew);
         .           	  }
         .           
         .           	// Check for out_of_range and length_error exceptions.
         .           	__try
12,308,214 ( 0.67%)  	  { this->_S_copy_chars(_M_data(), __beg, __end); }
         .           	__catch(...)
         .           	  {
         .           	    _M_dispose();
         .           	    __throw_exception_again;
         .           	  }
         .           
         .           	_M_set_length(__dnew);
         .                 }
-- line 233 ----------------------------------------
-- line 302 ----------------------------------------
         .           	      _M_destroy(__capacity);
         .           	      _M_data(_M_local_data());
         .           	    }
         .           	}
         .               }
         .           
         .             template<typename _CharT, typename _Traits, typename _Alloc>
         .               void
        24 ( 0.00%)      basic_string<_CharT, _Traits, _Alloc>::
         .               _M_mutate(size_type __pos, size_type __len1, const _CharT* __s,
         .           	      size_type __len2)
         .               {
        10 ( 0.00%)        const size_type __how_much = length() - __pos - __len1;
         .           
         6 ( 0.00%)        size_type __new_capacity = length() + __len2 - __len1;
         .                 pointer __r = _M_create(__new_capacity, capacity());
         .           
        14 ( 0.00%)        if (__pos)
         4 ( 0.00%)  	this->_S_copy(__r, _M_data(), __pos);
         8 ( 0.00%)        if (__s && __len2)
         2 ( 0.00%)  	this->_S_copy(__r + __pos, __s, __len2);
         6 ( 0.00%)        if (__how_much)
         .           	this->_S_copy(__r + __pos + __len2,
         .           		      _M_data() + __pos + __len1, __how_much);
         .           
         .                 _M_dispose();
         .                 _M_data(__r);
         .                 _M_capacity(__new_capacity);
        18 ( 0.00%)      }
         .           
         .             template<typename _CharT, typename _Traits, typename _Alloc>
         .               void
         .               basic_string<_CharT, _Traits, _Alloc>::
         .               _M_erase(size_type __pos, size_type __n)
         .               {
         .                 const size_type __how_much = length() - __pos - __n;
         .           
-- line 338 ----------------------------------------
-- line 354 ----------------------------------------
         .           	this->_M_set_length(__n);
         .               }
         .           
         .             template<typename _CharT, typename _Traits, typename _Alloc>
         .               basic_string<_CharT, _Traits, _Alloc>&
         .               basic_string<_CharT, _Traits, _Alloc>::
         .               _M_append(const _CharT* __s, size_type __n)
         .               {
         2 ( 0.00%)        const size_type __len = __n + this->size();
         .           
         6 ( 0.00%)        if (__len <= this->capacity())
         .           	{
         .           	  if (__n)
         .           	    this->_S_copy(this->_M_data() + this->size(), __s, __n);
         .           	}
         .                 else
         .           	this->_M_mutate(this->size(), size_type(0), __s, __n);
         .           
         .                 this->_M_set_length(__len);
-- line 372 ----------------------------------------
-- line 391 ----------------------------------------
         .               basic_string<_CharT, _Traits, _Alloc>&
         .               basic_string<_CharT, _Traits, _Alloc>::
         .               _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
         .           		   _CharT __c)
         .               {
         .                 _M_check_length(__n1, __n2, "basic_string::_M_replace_aux");
         .           
         .                 const size_type __old_size = this->size();
 8,592,960 ( 0.47%)        const size_type __new_size = __old_size + __n2 - __n1;
         .           
15,560,020 ( 0.84%)        if (__new_size <= this->capacity())
         .           	{
         .           	  pointer __p = this->_M_data() + __pos1;
         .           
         .           	  const size_type __how_much = __old_size - __pos1 - __n1;
         .           	  if (__how_much && __n1 != __n2)
         .           	    this->_S_move(__p + __n2, __p + __n1, __how_much);
         .           	}
         .                 else
   400,802 ( 0.02%)  	this->_M_mutate(__pos1, __n1, 0, __n2);
       290 ( 0.00%)  => /usr/include/c++/9/bits/basic_string.tcc:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_mutate(unsigned long, unsigned long, char const*, unsigned long) (2x)
         .           
         .                 if (__n2)
         .           	this->_S_assign(this->_M_data() + __pos1, __n2, __c);
         .           
         .                 this->_M_set_length(__new_size);
         .                 return *this;
         .               }
         .           
         .             template<typename _CharT, typename _Traits, typename _Alloc>
         .               basic_string<_CharT, _Traits, _Alloc>&
 3,658,275 ( 0.20%)      basic_string<_CharT, _Traits, _Alloc>::
         .               _M_replace(size_type __pos, size_type __len1, const _CharT* __s,
         .           	       const size_type __len2)
         .               {
         .                 _M_check_length(__len1, __len2, "basic_string::_M_replace");
         .           
         .                 const size_type __old_size = this->size();
   406,475 ( 0.02%)        const size_type __new_size = __old_size + __len2 - __len1;
         .           
   812,950 ( 0.04%)        if (__new_size <= this->capacity())
         .           	{
   812,950 ( 0.04%)  	  pointer __p = this->_M_data() + __pos;
         .           
   406,475 ( 0.02%)  	  const size_type __how_much = __old_size - __pos - __len1;
         .           	  if (_M_disjunct(__s))
         .           	    {
   812,950 ( 0.04%)  	      if (__how_much && __len1 != __len2)
         .           		this->_S_move(__p + __len2, __p + __len1, __how_much);
   812,950 ( 0.04%)  	      if (__len2)
         .           		this->_S_copy(__p, __s, __len2);
         .           	    }
         .           	  else
         .           	    {
         .           	      // Work in-place.
         .           	      if (__len2 && __len2 <= __len1)
         .           		this->_S_move(__p, __s, __len2);
         .           	      if (__how_much && __len1 != __len2)
-- line 447 ----------------------------------------
-- line 462 ----------------------------------------
         .           		}
         .           	    }
         .           	}
         .                 else
         .           	this->_M_mutate(__pos, __len1, __s, __len2);
         .           
         .                 this->_M_set_length(__new_size);
         .                 return *this;
 3,658,275 ( 0.20%)      }
         .           
         .             template<typename _CharT, typename _Traits, typename _Alloc>
         .               typename basic_string<_CharT, _Traits, _Alloc>::size_type
         .               basic_string<_CharT, _Traits, _Alloc>::
         .               copy(_CharT* __s, size_type __n, size_type __pos) const
         .               {
         .                 _M_check(__pos, "basic_string::copy");
         .                 __n = _M_limit(__pos, __n);
-- line 478 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: bitio.cc
--------------------------------------------------------------------------------
Ir                  

-- line 22 ----------------------------------------
         .           int BitInput::read_n_bits(int n){
         .               int b = 0;
         .               for (int i= n-1; i >=0; i--){
         .                   b |= (input_bit()<<i);
         .               }
         .               return b;
         .           }
         .           
         5 ( 0.00%)  BitOutput::BitOutput(std::ostream& os): output_stream(os), index(CHAR_BIT-1), buffer(0) {}
         .           
         .           // if there is anything in buffer, we need to output upon destruction
         2 ( 0.00%)  BitOutput::~BitOutput(){
         4 ( 0.00%)      if(output_stream){
         2 ( 0.00%)          if(index<CHAR_BIT-1){
         3 ( 0.00%)              output_stream.put(buffer);
        64 ( 0.00%)  => ???:0x000000000010a300 (1x)
         .                   }
         .               }
         2 ( 0.00%)   }
         .           
         .           
         8 ( 0.00%)  void BitOutput::output_bit(bool bit){
         .           
20,907,324 ( 1.14%)      if (index == CHAR_BIT-1){
         .                   buffer = 0;
         .               }
         .           
         .               // we are going left to right, so save the bit then decrement the index
40,507,926 ( 2.20%)      buffer |= (bit<<index--);
         .           
         .               // if we've been given a whole byte, output it then start a new buffer
18,293,902 ( 0.99%)      if (index == -1){
 3,920,121 ( 0.21%)          output_stream.put(buffer);
83,656,676 ( 4.54%)  => ???:0x000000000010a300 (1,306,706x)
 3,920,119 ( 0.21%)          index = CHAR_BIT-1;
         .               }
         4 ( 0.00%)  }
         .           
 7,316,568 ( 0.40%)  void BitOutput::output_n_bits(int bits, int n){
32,986,875 ( 1.79%)      for (int i = n-1; i>=0; --i){
73,175,599 ( 3.97%)          output_bit((bits>>i)&1);
         .               }
 3,251,811 ( 0.18%)  }

--------------------------------------------------------------------------------
Ir                   
--------------------------------------------------------------------------------
859,296,085 (46.65%)  events annotated

